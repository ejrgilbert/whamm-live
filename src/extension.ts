import * as vscode from 'vscode';
import { WasmContext, Memory, Options } from '@vscode/wasm-component-model';
import { ExtensionContext} from './extensionContext';

// Imports for the sidebar UI
import {SidebarProvider} from './user_interface/sidebarProvider';
import { Helper_sidebar_provider } from './user_interface/sidebarProviderHelper';

// Imports to handle API calls to update "model"
import { debounce, DiagnosticCollection } from './extensionListeners/listenerHelper';
import { handleDocumentChanges, shouldUpdateModel} from './extensionListeners/documentChangesListener';

// Import the code generated by wit2ts
import { Types, whammServer } from './whammServer';
import { handleCursorChange, shouldUpdateView } from './extensionListeners/cursorChangesListener';

export async function activate(context: vscode.ExtensionContext): Promise<void> {
	// Store context for future uses
	ExtensionContext.context = context;

	// handle UI for webview with "live-whamm-webview" id
	SidebarProvider.createAndRegisterWebViewProvider(context, "live-whamm-webview");

	// The channel for printing the result.
	const channel = vscode.window.createOutputChannel('WhammClient');
	context.subscriptions.push(channel);

	// The channel for printing the log.
	const log = vscode.window.createOutputChannel('WhammServer - Log', { log: true });
	context.subscriptions.push(log);

	// Load the Wasm module
	const filename = vscode.Uri.joinPath(context.extensionUri, 'target', 'wasm32-unknown-unknown', 'debug', 'whamm_server.wasm');
	const bits = await vscode.workspace.fs.readFile(filename);
	const module = await WebAssembly.compile(bits);

	// The implementation of the log function that is called from WASM
	const service: whammServer.Imports = {
		log: (msg: string) => {
			log.info(msg);
		}
	};

	// The context for the WASM module
	const wasmContext: WasmContext.Default = new WasmContext.Default();

	// Create the bindings to import the log function into the WASM module
	const imports = whammServer._.imports.create(service, wasmContext);
	// Instantiate the module
	const instance = await WebAssembly.instantiate(module, imports);

	// Bind the WASM memory to the context
	wasmContext.initialize(new Memory.Default(instance.exports));

	// Bind the TypeScript Api
	const api = whammServer._.exports.bind(instance.exports as whammServer._.Exports, wasmContext);
	ExtensionContext.api = api;

	// Load the files
	const app_path = "demo/cf.wasm";
	const script_path = "demo/script.mm";
	const app_bytes = await loadFileAsBytes(app_path, context);
	const script_content = await loadFileAsString(script_path, context);

	// Register vscode commands
	context.subscriptions.push(vscode.commands.registerCommand("live-whamm:select-whamm-file", ()=>{
		if (vscode.window.activeTextEditor?.document?.fileName.endsWith(".mm")) {
			Helper_sidebar_provider.helper_show_whamm_file(vscode.window.activeTextEditor.document.uri);
		}
		else{
			vscode.window.showErrorMessage("[Live Whamm]: Cannot select a non .mm file");
		}
	}));

	context.subscriptions.push(vscode.commands.registerCommand("live-whamm:select-wasm-file", ()=>{
		const re = new RegExp(".*(\.wat|\.wasm)");
		const document : vscode.TextDocument | undefined= vscode.window.activeTextEditor?.document;
		if (document && document.fileName && re.test(document.fileName)){
			if (ExtensionContext.context.workspaceState.get('whamm-file'))
				Helper_sidebar_provider.helper_show_wasm_file(document.uri.fsPath);
			else 
				vscode.window.showWarningMessage("[Live Whamm]: Open a Whamm(.mm) file first");
		}
		else{
			vscode.window.showErrorMessage("[Live Whamm]: Cannot select a non .mm file");
		}
	}));

	context.subscriptions.push(vscode.commands.registerCommand('vscode-samples.wasm-component-model.run', () => {
		channel.show();
		channel.appendLine('Running WhammServer example');

		try {
			const result = api.setup(app_path,app_bytes, {asMonitorModule: false});
			channel.appendLine(`whamm setup success: ${result}`)
		} catch (error) {
			channel.appendLine(`whamm setup failed`)
			handleError(error, channel);
		}

		// TODO: this should be split out to a different async func callback! (should update script content each time)
		try {
			printProbe(api.run(script_content, app_path, script_path), channel);
		} catch (error) {
			channel.appendLine(`whamm run failed`)
			handleError(error, channel);
		}
	}));


	// Setup listeners to handle model(API data) changes
	{
		// Diagonistics for error handling
		DiagnosticCollection.create_collection();

		// debounce function will make sure the function `handleDocumentChanges`
		// will only be triggered once per our selected .mm file change
		let debounceFunction = debounce(handleDocumentChanges,1000);
		vscode.workspace.onDidChangeTextDocument((event: vscode.TextDocumentChangeEvent)=>{
			if (shouldUpdateModel()) debounceFunction();
		})
	}
	// handleCursorChange will make sure the webview view gets updated 
	// and this also uses the debounce technique to not update view frequently
	{
		let debounceFunction = debounce(handleCursorChange,1000);
		vscode.window.onDidChangeTextEditorSelection((event: vscode.TextEditorSelectionChangeEvent)=>{
			if (shouldUpdateView()) debounceFunction();
		})
	}
}

function handleError(error: unknown, channel: vscode.OutputChannel) {
	let name = 'UnknownError'
	let message = 'Failed due to some unknown reason.'
	if (error instanceof Types.ErrorCode.Error_) {
		name = error.cause.tag;
		message = error.cause.value;
	}
	
	channel.appendLine(`${name}: ${message}`);
}

function printProbe(probes: Types.Probe[], channel: vscode.OutputChannel) {
	probes.forEach ( ({
		appLoc,
		scriptLoc,
		wat
	}, i) => {
		channel.appendLine(`probe${i}:`);
		channel.appendLine(`  app_loc -> ${appLoc.byteOffset}:${appLoc.mode}`);
		channel.appendLine(`  script_loc -> ${scriptLoc.l}:${scriptLoc.c}`);
		channel.appendLine(`  wat -> ${wat}`);
	});
	channel.appendLine(`whamm run success!`)
}

async function loadFileAsString(path: string, context: vscode.ExtensionContext): Promise<string> {
	const encoded = await vscode.workspace.fs.readFile(vscode.Uri.file(context.asAbsolutePath(path)));
	return new TextDecoder('utf-8').decode(encoded);
}

async function loadFileAsBytes(path: string, context: vscode.ExtensionContext): Promise<Uint8Array> {
	return await vscode.workspace.fs.readFile(vscode.Uri.file(context.asAbsolutePath(path)));
}
