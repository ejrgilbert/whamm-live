import * as vscode from 'vscode';
import { WasmContext, Memory, Options, TupleType } from '@vscode/wasm-component-model';
import { ExtensionContext} from './extensionContext';

// Imports for the sidebar UI
import {SidebarProvider} from './user_interface/sidebarProvider';
import { Helper_sidebar_provider } from './user_interface/sidebarProviderHelper';

// Imports to handle API calls to update "model"
import { debounce, DiagnosticCollection, isExtensionActive } from './extensionListeners/utils/listenerHelper';
import { handleDocumentChanges, shouldUpdateModel} from './extensionListeners/documentChangesListener';

// Import the code generated by wit2ts
import { whammServer } from './whammServer';
import { handleCursorChange, shouldUpdateView } from './extensionListeners/cursorChangesListener';
import { LineHighlighterDecoration } from './extensionListeners/utils/lineHighlighterDecoration';

export async function activate(context: vscode.ExtensionContext): Promise<void> {
	// Store context for future uses
	ExtensionContext.context = context;

	// handle UI for webview with "live-whamm-webview" id
	SidebarProvider.createAndRegisterWebViewProvider(context, "live-whamm-webview");

	// The channel for printing the log.
	const log = vscode.window.createOutputChannel('WhammServer - Log', { log: true });
	context.subscriptions.push(log);

	// Load the Wasm module
	const filename = vscode.Uri.joinPath(context.extensionUri, 'target', 'wasm32-unknown-unknown', 'debug', 'whamm_server.wasm');
	const bits = await vscode.workspace.fs.readFile(filename);
	const module = await WebAssembly.compile(bits);

	// The implementation of the log function that is called from WASM
	const service: whammServer.Imports = {
		log: (msg: string) => {
			log.info(msg);
		}
	};

	// The context for the WASM module
	const wasmContext: WasmContext.Default = new WasmContext.Default();

	// Create the bindings to import the log function into the WASM module
	const imports = whammServer._.imports.create(service, wasmContext);
	// Instantiate the module
	const instance = await WebAssembly.instantiate(module, imports);

	// Bind the WASM memory to the context
	wasmContext.initialize(new Memory.Default(instance.exports));

	// Bind the TypeScript Api
	const api = whammServer._.exports.bind(instance.exports as whammServer._.Exports, wasmContext);
	ExtensionContext.api = api;

	// Register vscode commands
	context.subscriptions.push(vscode.commands.registerCommand("live-whamm:select-whamm-file", ()=>{
		if (vscode.window.activeTextEditor?.document?.fileName.endsWith(".mm")) {
			Helper_sidebar_provider.helper_show_whamm_file(vscode.window.activeTextEditor.document.uri);
		}
		else{
			vscode.window.showErrorMessage("[Live Whamm]: Cannot select a non .mm file");
		}
	}));

	context.subscriptions.push(vscode.commands.registerCommand("live-whamm:select-wasm-file", ()=>{
		const re = new RegExp(".*(\.wat|\.wasm)");
		const document : vscode.TextDocument | undefined= vscode.window.activeTextEditor?.document;
		if (document && document.fileName && re.test(document.fileName)){
			if (ExtensionContext.context.workspaceState.get('whamm-file'))
				Helper_sidebar_provider.helper_show_wasm_file(document.uri.fsPath);
			else 
				vscode.window.showWarningMessage("[Live Whamm]: Open a Whamm(.mm) file first");
		}
		else{
			vscode.window.showErrorMessage("[Live Whamm]: Cannot select a non .mm file");
		}
	}));

	// Setup listeners to handle model(API data) changes
	{
		// Diagonistics for error handling
		DiagnosticCollection.create_collection();

		// debounce function will make sure the function `handleDocumentChanges`
		// will only be triggered once per our selected .mm file change
		let debounceFunction = debounce(handleDocumentChanges, 500);
		vscode.workspace.onDidSaveTextDocument((event: vscode.TextDocument)=>{
			if (shouldUpdateModel()) debounceFunction();
		})
	}
	// handleCursorChange will make sure the webview view gets updated 
	// and this also uses the debounce technique to not update view frequently
	{
		let debounceFunction = debounce(handleCursorChange,500);
		vscode.window.onDidChangeTextEditorSelection((event: vscode.TextEditorSelectionChangeEvent)=>{
			if (shouldUpdateView()) debounceFunction();
		})
	}

	// Restore whamm decorations in the case the whamm monitor file was in the background
	// (which would have erased any previous decorations!)
	vscode.window.onDidChangeVisibleTextEditors((editors)=>{
		for (let editor of editors){
			if (editor.document.uri.fsPath === ExtensionContext.context.workspaceState.get("whamm-file")
				&& isExtensionActive() && LineHighlighterDecoration.decorations.length > 0){
					LineHighlighterDecoration.restore_whamm_file_decorations();
					break;
				}
		}
	});
}